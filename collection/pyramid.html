<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Precision Plinko</title>
    <style>
        body {
            background-color: #0f1923;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        #sidebar {
            width: 300px;
            background-color: #1a242d;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.5);
            z-index: 10;
        }

        h2 { margin: 0; font-size: 20px; }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label { font-size: 12px; color: #8b9bb4; font-weight: bold; }

        input[type="number"] {
            background: #0f1923;
            border: 1px solid #2f3b4b;
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
        }

        button#play-btn {
            background-color: #00e701;
            color: #000;
            border: none;
            padding: 15px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.1s;
        }

        button#play-btn:hover { background-color: #00c401; }
        button#play-btn:active { transform: scale(0.98); }

        #game-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background: radial-gradient(circle at center, #1a242d 0%, #0f1923 70%);
        }

        canvas {
            border-radius: 8px;
        }

        #wallet {
            background: #2f3b4b;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
            font-size: 14px;
            color: #fff;
        }

/* PHONE LAYOUT (Pyramid Top, Controls Bottom) */
    @media (max-width: 768px) {
        
        body {
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
        }

        /* GAME AREA (Top 70%) */
        canvas {
            order: 1;
            width: 100%;
            height: 70dvh;
            border-bottom: 2px solid #333;
        }

        /* CONTROLS AREA (Bottom 30%) */
        #sidebar {
            order: 2;
            width: 100%;
            height: 30dvh;
            border-right: none;
            border-top: 1px solid #333;
            
            display: flex;
            flex-direction: row; 
            flex-wrap: wrap; 
            justify-content: center;
            align-content: center; /* Vertically center the whole cluster */
            gap: 5px;
            padding: 15px;
        }

        /* Hide Title & Desc */
        #sidebar h2, #sidebar p { display: none; }

        /* 1. INPUT GROUP (Left Side) */
        #sidebar .input-group {
            width: 40% !important;
            flex: 0 0 45%; 
            margin: 0;
            padding: 0; /* Remove padding from container */
            background: none; /* Remove background if present */
            border: none;
            display: flex;
            flex-direction: column;
            justify-content: center; /* Align bottom to match button */
        }
        
        /* The actual input box */
        #sidebar input[type="number"] {
            width: 85%;
            height: 42px; /* FIXED HEIGHT */
            margin: 0;
            box-sizing: border-box;
            text-align: center;
        }

        #sidebar label {
            font-size: 10px;
            text-align: center;
            margin-bottom: 4px;
            width: 100%;
            display: block;
        }

        /* 2. DROP BUTTON (Right Side) */
        #sidebar button {
            width: 35% !important;
            flex: 0 0 35%;
            height: 42px; /* MATCH INPUT HEIGHT */
            margin-top: auto; /* Push down to align with input */
            font-size: 14px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* 3. BALANCE DISPLAY (Bottom Center) */
        /* Assuming your balance is in a div with id="balance-display" or similar class */
        /* You might need to add class="balance" to your balance div in HTML if it lacks one */
        .balance-container, #wallet, .input-group:last-child {
            order: 3;
            width: 100% !important;
            flex: 0 0 100%;
            text-align: center;
            margin-top: 15px;
            font-size: 18px;
            font-weight: bold;
            color: #4db8ff;
        }
    }

    </style>
</head>
<body>

    <div id="sidebar">
        <h2>Plinko</h2>
        <div class="control-group">
            <label>BET AMOUNT</label>
            <input type="number" id="betAmount" value="10" min="1">
        </div>
        <button id="play-btn">DROP BALL</button>
        <div id="wallet">Balance: $<span id="balance">1000.00</span></div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const btn = document.getElementById('play-btn');
    const balanceSpan = document.getElementById('balance');
    const betInput = document.getElementById('betAmount');

    // --- Configuration ---
    let balance = 1000;
    const ROWS = 16;
    // Tighter coordinates for accuracy
    const PEG_RADIUS = 3; 
    const BALL_RADIUS = 4.5; // Slightly smaller ball
    const SPACING = 33; // Tighter spacing
    
    const WIDTH = 800;
    const HEIGHT = 700;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    // Multipliers
    const MULTIPLIER_VALS = [110, 41, 10, 5, 3, 1.5, 1, 0.5, 0.3, 0.5, 1, 1.5, 3, 5, 10, 41, 110];

    // Colors
    function getColorForMultiplier(val) {
        if (val >= 10) return '#ff003f';
        if (val >= 3) return '#ff7f00';
        if (val >= 1) return '#ffce00';
        return '#ffff00';
    }

    // --- Game State ---
    const pegs = [];
    const balls = [];
    const particles = [];
    const buckets = [];

    // Center Setup
    const startX = WIDTH / 2;
    const startY = 50; 

    // 1. Generate Pegs
    for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col <= row + 2; col++) {
            const x = startX + (col - (row + 2) / 2) * SPACING;
            const y = startY + row * SPACING;
            pegs.push({ x, y, r: PEG_RADIUS });
        }
    }

    // 2. Generate Buckets (Hit Boxes)
    const floorY = startY + ROWS * SPACING + 25;
    const bucketW = SPACING - 5; // Width of the hit box
    const bucketH = 25;
    
    for (let i = 0; i < MULTIPLIER_VALS.length; i++) {
        const x = startX + (i - Math.floor(MULTIPLIER_VALS.length / 2)) * SPACING;
        buckets.push({
            x: x - bucketW/2,
            y: floorY,
            w: bucketW,
            h: bucketH,
            val: MULTIPLIER_VALS[i],
            color: getColorForMultiplier(MULTIPLIER_VALS[i]),
            hitAnim: 0 // For visual pop effect
        });
    }

    // --- Classes ---

    class Ball {
        constructor() {
            this.x = startX + (Math.random() - 0.5); // Minimal jitter at spawn
            this.y = 20;
            this.vx = (Math.random() - 0.5) * 0.5; // Tiny initial drift
            this.vy = 0;
            this.r = BALL_RADIUS;
            this.color = '#ffffff';
            this.gravity = 0.2;
            this.friction = 0.99;
            this.active = true;
            this.bet = parseFloat(betInput.value);
        }

        update() {
            if (!this.active) return;

            this.vy += this.gravity;
            this.vx *= this.friction;
            
            this.x += this.vx;
            this.y += this.vy;

            // PEG COLLISION
            for (let peg of pegs) {
                const dx = this.x - peg.x;
                const dy = this.y - peg.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < this.r + peg.r) {
                    const angle = Math.atan2(dy, dx);
                    
                    // Push out
                    const overlap = (this.r + peg.r) - dist;
                    this.x += Math.cos(angle) * overlap;
                    this.y += Math.sin(angle) * overlap;

                    // Bounce logic
                    this.vx += Math.cos(angle) * 1.5 + (Math.random() - 0.5) * 0.5;
                    this.vy *= -0.5;
                }
            }

            // BUCKET COLLISION (Precise AABB)
            // Only check if we are low enough
            if (this.y > floorY - 10) {
                for (let b of buckets) {
                    // Check if ball center is inside the box bounds
                    if (this.x > b.x && this.x < b.x + b.w &&
                        this.y > b.y && this.y < b.y + b.h) {
                        
                        this.finish(b);
                        break;
                    }
                }
            }
            
            // Failsafe: if it misses everything and falls off
            if (this.y > HEIGHT + 50) this.active = false;
        }

        finish(bucket) {
            this.active = false;
            const payout = this.bet * bucket.val;
            balance += payout;
            updateBalance();
            
            // Trigger Visuals
            bucket.hitAnim = 10; // Frames of animation
            createWinEffect(bucket.x + bucket.w/2, bucket.y, bucket.val, bucket.color);
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 5;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    class Particle {
        constructor(x, y, text, color) {
            this.x = x;
            this.y = y;
            this.text = text;
            this.color = color;
            this.life = 1.0;
            this.vy = -1.5;
        }
        update() {
            this.y += this.vy;
            this.life -= 0.02;
        }
        draw() {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.font = "bold 16px Arial";
            ctx.textAlign = "center";
            ctx.fillText(this.text + "x", this.x, this.y);
            ctx.globalAlpha = 1.0;
        }
    }

    // --- Visual Functions ---

    function createWinEffect(x, y, val, color) {
        particles.push(new Particle(x, y, val, color));
    }

    function updateBalance() {
        balanceSpan.innerText = balance.toFixed(2);
    }

    function drawVisualWalls() {
        // Calculate the positions of the bottom-left and bottom-right pegs
        const leftPeg = pegs[pegs.length - (ROWS + 2)]; // Approx last row start
        const rightPeg = pegs[pegs.length - 1]; // Last row end

        // Start point (Top)
        const topX = WIDTH / 2;
        const topY = 40;

        // Visual Wall Left
        ctx.beginPath();
        ctx.moveTo(topX - 15, topY); 
        // We draw a line parallel to the pyramid slope
        // The slope expands by SPACING/2 per row.
        ctx.lineTo(topX - 15 - (ROWS * SPACING/2) - 20, floorY); 
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Visual Wall Right
        ctx.beginPath();
        ctx.moveTo(topX + 15, topY); 
        ctx.lineTo(topX + 15 + (ROWS * SPACING/2) + 20, floorY); 
        ctx.stroke();
    }

    function animate() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        drawVisualWalls();

        // Draw Buckets
        for (let b of buckets) {
            // Animation logic: if hitAnim > 0, box is slightly bigger/brighter
            let scaleOffset = 0;
            let alpha = 1;
            
            if (b.hitAnim > 0) {
                scaleOffset = 4; // Pop effect
                b.hitAnim--;
                ctx.fillStyle = "white"; // Flash white
            } else {
                ctx.fillStyle = b.color;
                ctx.globalAlpha = 0.8; // Slightly transparent normally
            }

            // Draw Box
            ctx.beginPath();
            ctx.roundRect(
                b.x - scaleOffset/2, 
                b.y - scaleOffset/2, 
                b.w + scaleOffset, 
                b.h + scaleOffset, 
                4
            );
            ctx.fill();
            ctx.globalAlpha = 1.0;

            // Draw Text
            ctx.fillStyle = (b.val >= 10 || b.val < 1) ? "#000" : "#000";
            ctx.font = "bold 10px Arial";
            ctx.textAlign = "center";
            ctx.fillText(b.val + "x", b.x + b.w/2, b.y + 16);
        }

        // Draw Pegs
        ctx.fillStyle = "white";
        for (let p of pegs) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Balls
        for (let i = balls.length - 1; i >= 0; i--) {
            let b = balls[i];
            b.update();
            b.draw();
            if (!b.active) balls.splice(i, 1);
        }

        // Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.update();
            p.draw();
            if (p.life <= 0) particles.splice(i, 1);
        }

        requestAnimationFrame(animate);
    }

    btn.addEventListener('click', () => {
        const bet = parseFloat(betInput.value);
        if (balance >= bet) {
            balance -= bet;
            updateBalance();
            balls.push(new Ball());
        } else {
            // Flash red on insufficient funds
            balanceSpan.style.color = "red";
            setTimeout(() => balanceSpan.style.color = "white", 200);
        }
    });

    animate();
</script>
</body>
</html>