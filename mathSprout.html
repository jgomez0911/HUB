<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Sprout v2</title>
    <style>
        body {
            margin: 0;
            background-color: #1a221a;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            user-select: none; /* Prevents text selection while double clicking */
        }

        /* Sidebar */
        #sidebar {
            width: 200px;
            background-color: #223322;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-right: 2px solid #44aa44;
            box-shadow: 2px 0 15px rgba(0,0,0,0.5);
            z-index: 10;
        }

        h2 { margin: 0 0 15px 0; color: #44ffaa; text-align: center; }
        p.hint { font-size: 13px; color: #8b9; text-align: center; margin-bottom: 20px; line-height: 1.4;}

        .spawner-group {
            display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;
            margin-bottom: 20px;
        }

        button {
            width: 50px; height: 50px;
            border-radius: 50%;
            border: none; font-size: 20px; font-weight: bold;
            cursor: pointer; transition: transform 0.1s, box-shadow 0.2s;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px rgba(0,0,0,0.2);
        }
        button:active { transform: translateY(2px); box-shadow: 0 1px rgba(0,0,0,0.2); }

        .btn-num { background: #e0c090; color: #3d2e1f; border: 3px solid #8b5a2b; }
        .btn-op { background: #a0e0a0; color: #1a3d1a; border: 3px solid #44aa44; }
        
        #clearBtn { width: 100%; border-radius: 8px; background: #8b5a2b; color: white; font-size: 16px; padding: 10px; }
        #clearBtn:hover { background: #a06b35; }

        /* Canvas */
        #canvas-container {
            flex-grow: 1;
            position: relative;
            background: radial-gradient(circle at center, #1a2a1a 0%, #0f150f 100%);
            cursor: default;
        }

        canvas { display: block; width: 100%; height: 100%; }
        
        /* Status Text overlay */
        #status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #44ffaa;
            font-size: 18px;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <h2>Math Sprout</h2>
        <p class="hint">
            <b>Single Click & Drag</b> to move.<br><br>
            <b>Double Click</b> a number to grow a vine, then click an operator to connect.
        </p>
        
        <div class="spawner-group">
            <button class="btn-num" onclick="spawnNumber(1)">1</button>
            <button class="btn-num" onclick="spawnNumber(2)">2</button>
            <button class="btn-num" onclick="spawnNumber(3)">3</button>
            <button class="btn-num" onclick="spawnNumber(5)">5</button>
            <button class="btn-num" onclick="spawnNumber(10)">10</button>
        </div>

        <div class="spawner-group">
            <button class="btn-op" onclick="spawnOperator('+')">+</button>
            <button class="btn-op" onclick="spawnOperator('-')">−</button>
            <button class="btn-op" onclick="spawnOperator('×')">×</button>
            <button class="btn-op" onclick="spawnOperator('÷')">÷</button>
        </div>

        <button id="clearBtn" onclick="clearGarden()">Clear Garden</button>
    </div>

    <div id="canvas-container">
        <div id="status">Select an operator to connect...</div>
        <canvas id="gardenCanvas"></canvas>
    </div>

<script>
    const canvas = document.getElementById('gardenCanvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');

    function resize() {
        canvas.width = canvas.parentElement.offsetWidth;
        canvas.height = canvas.parentElement.offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Data Structures ---

    let nodeIdCounter = 0;
    let nodes = [];
    let connections = [];

    class Node {
        constructor(x, y, type) {
            this.id = nodeIdCounter++;
            this.x = x;
            this.y = y;
            this.type = type; 
            this.radius = 35;
            this.isDragging = false;
            this.spawnScale = 0; 
            this.targetScale = 1;
            this.highlight = false; // For double-click feedback
        }
        update() {
            if (this.spawnScale < this.targetScale) {
                this.spawnScale += (this.targetScale - this.spawnScale) * 0.15;
            }
        }
    }

    class NumberNode extends Node {
        constructor(x, y, value, isResult = false) {
            super(x, y, 'number');
            this.value = value;
            this.isResult = isResult; 
            this.radius = isResult ? 40 : 35;
        }
    }

    class OperatorNode extends Node {
        constructor(x, y, opSymbol) {
            super(x, y, 'operator');
            this.opSymbol = opSymbol;
            this.inputs = []; 
        }
    }

    function spawnNumber(val) {
        nodes.push(new NumberNode(100, 100 + nodes.length * 20, val));
    }

    function spawnOperator(symbol) {
        nodes.push(new OperatorNode(250, 150 + nodes.length * 20, symbol));
    }

    function spawnResult(x, y, val) {
        // Offset output slightly so it doesn't overlap perfectly if spawn logic is generic
        const resultNode = new NumberNode(x, y, val, true);
        nodes.push(resultNode);
        return resultNode;
    }

    function clearGarden() {
        nodes = [];
        connections = [];
        cancelWiring();
    }

    // --- Interaction State ---
    let dragTarget = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    
    // Wiring State
    let isWiring = false;
    let wireSourceNode = null;
    let wireMousePos = { x: 0, y: 0 };

    function cancelWiring() {
        isWiring = false;
        if(wireSourceNode) wireSourceNode.highlight = false;
        wireSourceNode = null;
        statusDiv.style.opacity = "0";
        canvas.style.cursor = "default";
    }

    // --- Helper Functions ---
    function dist(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1)**2 + (y2 - y1)**2);
    }

    function getNodeAt(x, y) {
        for (let i = nodes.length - 1; i >= 0; i--) {
            const n = nodes[i];
            if (dist(x, y, n.x, n.y) < n.radius) {
                return n;
            }
        }
        return null;
    }

    function tryCalculate(opNode) {
        if (opNode.inputs.length !== 2) return;

        const input1 = nodes.find(n => n.id === opNode.inputs[0]);
        const input2 = nodes.find(n => n.id === opNode.inputs[1]);

        if (!input1 || !input2) return;

        let resultVal = 0;
        let v1 = input1.value;
        let v2 = input2.value;

        switch(opNode.opSymbol) {
            case '+': resultVal = v1 + v2; break;
            case '-': resultVal = v1 - v2; break;
            case '×': resultVal = v1 * v2; break;
            case '÷': 
                resultVal = v2 === 0 ? "?" : parseFloat((v1 / v2).toFixed(1)); 
                if (typeof resultVal === 'number' && resultVal.toString().endsWith('.0')) resultVal = parseInt(resultVal);
                break;
        }

        const resultNode = spawnResult(opNode.x + 140, opNode.y, resultVal);
        connections.push({ from: opNode.id, to: resultNode.id, isAuto: true });
    }

    // --- MOUSE EVENTS ---

    // 1. Double Click to START wiring
    canvas.addEventListener('dblclick', (e) => {
        const r = canvas.getBoundingClientRect();
        const x = e.clientX - r.left;
        const y = e.clientY - r.top;
        
        const clickedNode = getNodeAt(x, y);

        if (clickedNode && clickedNode.type === 'number') {
            // Start wiring mode
            isWiring = true;
            wireSourceNode = clickedNode;
            wireSourceNode.highlight = true;
            wireMousePos = { x, y };
            
            // UI Feedback
            statusDiv.textContent = "Click an operator to connect...";
            statusDiv.style.opacity = "1";
            canvas.style.cursor = "crosshair";
        }
    });

    // 2. Mouse Down (Handles Dragging AND Completing Wire)
    canvas.addEventListener('mousedown', (e) => {
        const r = canvas.getBoundingClientRect();
        const x = e.clientX - r.left;
        const y = e.clientY - r.top;
        const clickedNode = getNodeAt(x, y);

        // CASE A: We are currently wiring (drawing a line)
        if (isWiring) {
            if (clickedNode && clickedNode.type === 'operator') {
                // Success: Connect
                if (clickedNode.inputs.length < 2) {
                    connections.push({ from: wireSourceNode.id, to: clickedNode.id, isAuto: false });
                    clickedNode.inputs.push(wireSourceNode.id);
                    tryCalculate(clickedNode);
                }
            }
            // Whether we hit a node or background, clicking ends wiring mode
            cancelWiring();
            return; // Don't start dragging immediately after connecting
        }

        // CASE B: Normal Dragging
        if (clickedNode) {
            dragTarget = clickedNode;
            dragTarget.isDragging = true;
            dragOffsetX = x - clickedNode.x;
            dragOffsetY = y - clickedNode.y;
            
            // Bring to front
            nodes.splice(nodes.indexOf(clickedNode), 1);
            nodes.push(clickedNode);
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        const r = canvas.getBoundingClientRect();
        const x = e.clientX - r.left;
        const y = e.clientY - r.top;

        if (dragTarget) {
            dragTarget.x = x - dragOffsetX;
            dragTarget.y = y - dragOffsetY;
        }

        if (isWiring) {
            wireMousePos = { x, y };
        }
    });

    canvas.addEventListener('mouseup', () => {
        if (dragTarget) {
            dragTarget.isDragging = false;
            dragTarget = null;
        }
    });


    // --- RENDERING ---

    function drawConnection(x1, y1, x2, y2, isAuto) {
        const midX = (x1 + x2) / 2;
        const curveY = isAuto ? Math.min(y1, y2) - 50 : (y1 + y2) / 2 + (Math.abs(x1-x2)*0.2);

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.quadraticCurveTo(midX, curveY, x2, y2);
        
        ctx.lineWidth = isAuto ? 6 : 4;
        ctx.strokeStyle = isAuto ? '#88cc88' : '#66aa66'; 
        ctx.lineCap = 'round';
        ctx.stroke();

        ctx.lineWidth = 2;
        ctx.strokeStyle = '#aaffaa';
        ctx.stroke();
    }

    function drawNode(node) {
        const r = node.radius * node.spawnScale;
        ctx.save();
        ctx.translate(node.x, node.y);

        // Highlight ring if selected for wiring
        if (node.highlight) {
            ctx.beginPath();
            ctx.arc(0, 0, r + 8, 0, Math.PI * 2);
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 4;
            ctx.stroke();
        }

        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);

        if (node.type === 'number') {
            if (node.isResult) {
                // FRUIT STYLE (Output)
                ctx.fillStyle = '#ff6b6b'; // Red/Pink Fruit
                ctx.fill();
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#c23b22'; // Dark Red Border
                ctx.stroke();
                
                // Shine spot
                ctx.beginPath();
                ctx.arc(-r*0.3, -r*0.3, r*0.2, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fill();
            } else {
                // SEED STYLE (Input)
                ctx.fillStyle = '#e0c090'; // Wood
                ctx.fill();
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#8b5a2b'; // Brown Border
                ctx.stroke();
            }

            // Text
            ctx.fillStyle = node.isResult ? '#fff' : '#3d2e1f';
            ctx.font = "bold " + (r*0.8) + "px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(node.value, 0, 0);

        } else {
            // LEAF STYLE (Operator)
            ctx.fillStyle = '#a0e0a0';
            ctx.fill();
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#44aa44';
            ctx.stroke();

            // Input Slots
            ctx.fillStyle = node.inputs.length > 0 ? '#44aa44' : '#ccffcc';
            ctx.beginPath(); ctx.arc(-r*0.6, -r*0.6, 5, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = node.inputs.length > 1 ? '#44aa44' : '#ccffcc';
            ctx.beginPath(); ctx.arc(-r*0.6, r*0.6, 5, 0, Math.PI*2); ctx.fill();

            // Text
            ctx.fillStyle = '#1a3d1a';
            ctx.font = "bold " + (r*1.0) + "px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(node.opSymbol, 0, 2);
        }

        ctx.restore();
    }

    function animate() {
        requestAnimationFrame(animate);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        nodes.forEach(n => n.update());

        // Existing Connections
        connections.forEach(conn => {
            const n1 = nodes.find(n => n.id === conn.from);
            const n2 = nodes.find(n => n.id === conn.to);
            if (n1 && n2) {
                drawConnection(n1.x, n1.y, n2.x, n2.y, conn.isAuto);
            }
        });

        // Active Wiring Line
        if (isWiring && wireSourceNode) {
            drawConnection(wireSourceNode.x, wireSourceNode.y, wireMousePos.x, wireMousePos.y, false);
        }

        // Nodes
        nodes.forEach(node => drawNode(node));
    }

    animate();

    // Initial Example
    setTimeout(() => {
         spawnNumber(3); spawnNumber(4); spawnOperator('×');
         nodes[0].x = 300; nodes[0].y = 200;
         nodes[1].x = 300; nodes[1].y = 300;
         nodes[2].x = 450; nodes[2].y = 250;
    }, 100);

</script>
</body>
</html>