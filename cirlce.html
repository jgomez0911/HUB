<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Lines Battle</title>
    <style>
        body {
            margin: 0;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: sans-serif;
            flex-direction: column;
        }
        canvas {
            background-color: #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 50%; /* Just for looks, the logic handles the circle */
        }
        #ui {
            margin-bottom: 10px;
            text-align: center;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #4CAF50;
            border: none;
            color: white;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h2>Tether Battle</h2>
        <p>Bounce to create lines. Cut opponent's lines. No lines = Game Over.</p>
        <div id="status">Status: Playing</div>
        <button onclick="resetGame()">Restart Game</button>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');

    // Game Config
    const SIZE = 600;
    canvas.width = SIZE;
    canvas.height = SIZE;
    const CENTER = { x: SIZE / 2, y: SIZE / 2 };
    const ARENA_RADIUS = 280;
    const BALL_RADIUS = 15;
    const MAX_SPEED = 40;

    let gameOver = false;

    // Helper: Distance between two points
    function dist(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }

    // Helper: Distance from point (p) to line segment (v, w)
    function distToSegment(p, v, w) {
        const l2 = dist(v.x, v.y, w.x, w.y) ** 2;
        if (l2 === 0) return dist(p.x, p.y, v.x, v.y);
        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        const projection = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
        return dist(p.x, p.y, projection.x, projection.y);
    }

    class Ball {
        constructor(color, startX, startY) {
            this.color = color;
            this.pos = { x: startX, y: startY };
            // Give them slightly different starting velocities
            this.vel = { 
                x: (Math.random() > 0.5 ? 1 : -1) * 3, 
                y: (Math.random() > 0.5 ? 1 : -1) * 3 
            };
            this.radius = BALL_RADIUS;
            this.lines = []; 
            this.createInitialTether();
        }

        createInitialTether() {
            const angle = Math.atan2(this.pos.y - CENTER.y, this.pos.x - CENTER.x);
            const anchor = {
                x: CENTER.x + Math.cos(angle) * ARENA_RADIUS,
                y: CENTER.y + Math.sin(angle) * ARENA_RADIUS
            };
            this.lines.push({ anchor: anchor });
        }

        update() {
            if (gameOver) return;

            // Apply Velocity
            this.pos.x += this.vel.x;
            this.pos.y += this.vel.y;

            // Wall Collision
            const d = dist(this.pos.x, this.pos.y, CENTER.x, CENTER.y);
            
            if (d + this.radius > ARENA_RADIUS) {
                const nx = (this.pos.x - CENTER.x) / d;
                const ny = (this.pos.y - CENTER.y) / d;

                // Push ball back inside
                this.pos.x = CENTER.x + nx * (ARENA_RADIUS - this.radius);
                this.pos.y = CENTER.y + ny * (ARENA_RADIUS - this.radius);

                // Reflect Velocity
                const dotProduct = this.vel.x * nx + this.vel.y * ny;
                this.vel.x = this.vel.x - 2 * dotProduct * nx;
                this.vel.y = this.vel.y - 2 * dotProduct * ny;

                // Add Line on bounce
                this.addLine(this.pos.x, this.pos.y);
            }
        }

        addLine(x, y) {
            this.lines.push({ anchor: { x: x, y: y } });
        }

        draw(ctx) {
            // Draw Lines
            ctx.lineWidth = 2;
            ctx.strokeStyle = this.color;
            for (let line of this.lines) {
                ctx.beginPath();
                ctx.moveTo(line.anchor.x, line.anchor.y);
                ctx.lineTo(this.pos.x, this.pos.y);
                ctx.stroke();
            }

            // Draw Ball
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.stroke();
        }
    }

    let ball1, ball2;

    function resolveBallCollision() {
        const dx = ball2.pos.x - ball1.pos.x;
        const dy = ball2.pos.y - ball1.pos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Check if balls are touching
        if (distance < ball1.radius + ball2.radius) {
            
            // 1. Resolve Overlap (prevent sticking)
            // Move them apart so they aren't inside each other
            const overlap = (ball1.radius + ball2.radius - distance) / 2;
            const nx = dx / distance; // Normal X
            const ny = dy / distance; // Normal Y
            
            ball1.pos.x -= nx * overlap;
            ball1.pos.y -= ny * overlap;
            ball2.pos.x += nx * overlap;
            ball2.pos.y += ny * overlap;

            // 2. Bounce Physics (Elastic Collision)
            // Calculate relative velocity
            const tx = -ny; // Tangent X
            const ty = nx;  // Tangent Y

            // Dot Product Tangent
            const dpTan1 = ball1.vel.x * tx + ball1.vel.y * ty;
            const dpTan2 = ball2.vel.x * tx + ball2.vel.y * ty;

            // Dot Product Normal
            const dpNorm1 = ball1.vel.x * nx + ball1.vel.y * ny;
            const dpNorm2 = ball2.vel.x * nx + ball2.vel.y * ny;

            // Conservation of momentum (1D collision along normal)
            // Since masses are equal, velocities along normal simply swap
            const m1 = (dpNorm1 * (ball1.radius - ball2.radius) + 2 * ball2.radius * dpNorm2) / (ball1.radius + ball2.radius);
            const m2 = (dpNorm2 * (ball2.radius - ball1.radius) + 2 * ball1.radius * dpNorm1) / (ball1.radius + ball2.radius);

            // Update velocities
            // Note: Since masses are equal, this simplifies to swapping normal components
            ball1.vel.x = tx * dpTan1 + nx * dpNorm2;
            ball1.vel.y = ty * dpTan1 + ny * dpNorm2;
            ball2.vel.x = tx * dpTan2 + nx * dpNorm1;
            ball2.vel.y = ty * dpTan2 + ny * dpNorm1;
        }
    }

    function init() {
        ball1 = new Ball('#FF4444', CENTER.x - 100, CENTER.y);
        ball2 = new Ball('#4444FF', CENTER.x + 100, CENTER.y);
        gameOver = false;
        statusDiv.innerHTML = "Status: <b>PLAYING</b>";
        statusDiv.style.color = "white";
        animate();
    }

    function checkLineCuts() {
        if (gameOver) return;

        // Check Ball 1 vs Ball 2's lines
        for (let i = ball2.lines.length - 1; i >= 0; i--) {
            const line = ball2.lines[i];
            const d = distToSegment(ball1.pos, line.anchor, ball2.pos);
            if (d < ball1.radius + 2) ball2.lines.splice(i, 1);
        }

        // Check Ball 2 vs Ball 1's lines
        for (let i = ball1.lines.length - 1; i >= 0; i--) {
            const line = ball1.lines[i];
            const d = distToSegment(ball2.pos, line.anchor, ball1.pos);
            if (d < ball2.radius + 2) ball1.lines.splice(i, 1);
        }

        if (ball1.lines.length === 0) endGame("BLUE WINS!");
        else if (ball2.lines.length === 0) endGame("RED WINS!");
    }

    function endGame(msg) {
        gameOver = true;
        statusDiv.innerHTML = `Status: <b>${msg}</b>`;
        statusDiv.style.color = msg.includes("RED") ? "#FF4444" : "#4444FF";
    }

    function resetGame() {
        init();
    }

    function drawArena() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.arc(CENTER.x, CENTER.y, ARENA_RADIUS, 0, Math.PI * 2);
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 5;
        ctx.stroke();
    }

    function animate() {
        if (!gameOver) requestAnimationFrame(animate);

        ball1.update();
        ball2.update();
        
        // NEW: Check if balls hit each other
        resolveBallCollision();
        
        // Check if balls hit lines
        checkLineCuts();

        drawArena();
        ball1.draw(ctx);
        ball2.draw(ctx);
        
        ctx.font = "20px Arial";
        ctx.fillStyle = ball1.color;
        ctx.fillText(`Red Lines: ${ball1.lines.length}`, 20, 30);
        ctx.fillStyle = ball2.color;
        ctx.fillText(`Blue Lines: ${ball2.lines.length}`, SIZE - 160, 30);
    }

    init();
</script>
</body>
</html>